{"version":3,"sources":["sw.js"],"names":["OFFLINE_VERSION","CACHE_NAME","OFFLINE_URL","self","addEventListener","event","waitUntil","caches","open","cache","add","Request","registration","navigationPreload","enable","clients","claim","request","mode","respondWith","preloadResponse","fetch","networkResponse","console","log","match","cachedResponse"],"mappings":";AAgCA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,MAAA,GAAA,YAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAAA,QAAA,QAAA,GAAA,KAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,WAAA,IAAA,EAAA,KAAA,EAAA,UAAA,OAAA,IAAA,QAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,EAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,GAAA,OAAA,MA9BA,IAAMA,EAAkB,EAClBC,EAAa,UACbC,EAAc,aAEpBC,KAAKC,iBAAiB,UAAW,SAACC,GAChCA,EAAMC,UACJ,EAAC,mBAAA,KAAA,SAAA,IAAA,IAAA,EAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EACqBC,OADrB,EAAA,KAAA,EACqBA,OAAOC,KAAKP,GADjC,KAAA,EAIOQ,OAHAA,EADP,EAAA,KAAA,EAAA,KAAA,EAIOA,EAAMC,IAAI,IAAIC,QAAQT,EAAa,CAAEO,MAAO,YAJnD,KAAA,EAAA,IAAA,MAAA,OAAA,EAAA,SAAA,KAAD,MASJN,KAAKC,iBAAiB,WAAY,SAACC,GACjCA,EAAMC,UACJ,EAAC,mBAAA,KAAA,SAAA,IAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EAGK,KAAA,sBAAuBH,KAAKS,cAHjC,CAAA,EAAA,KAAA,EAAA,MAIST,OAJT,EAAA,KAAA,EAISA,KAAKS,aAAaC,kBAAkBC,SAJ7C,KAAA,EAAA,IAAA,MAAA,OAAA,EAAA,SAAA,KAAD,IAUFX,KAAKY,QAAQC,UAGfb,KAAKC,iBAAiB,QAAS,SAACC,GAGH,aAAvBA,EAAMY,QAAQC,MAChBb,EAAMc,YACJ,EAAC,mBAAA,KAAA,SAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EAGiCd,OAHjC,EAAA,KAAA,EAAA,EAAA,KAAA,EAGiCA,EAAMe,gBAHvC,KAAA,EAIOA,KADEA,EAHT,EAAA,MAAA,CAAA,EAAA,KAAA,EAAA,MAKYA,OAAAA,EAAAA,OAAAA,SAAAA,GALZ,KAAA,EAQiCC,OARjC,EAAA,KAAA,EAQiCA,MAAMhB,EAAMY,SAR7C,KAAA,EASUK,OADDA,EART,EAAA,KASUA,EAAAA,OAAAA,SAAAA,GATV,KAAA,GAiBuBf,OAjBvB,EAAA,KAAA,GAAA,EAAA,GAAA,EAAA,MAAA,GAeGgB,QAAQC,IAAI,gDAAZ,EAAA,IAfH,EAAA,KAAA,GAiBuBjB,OAAOC,KAAKP,GAjBnC,KAAA,GAkBgCQ,OADvBA,EAjBT,EAAA,KAAA,EAAA,KAAA,GAkBgCA,EAAMgB,MAAMvB,GAlB5C,KAAA,GAmBUwB,OADDA,EAlBT,EAAA,KAmBUA,EAAAA,OAAAA,SAAAA,GAnBV,KAAA,GAAA,IAAA,MAAA,OAAA,EAAA,SAAA,EAAA,KAAA,CAAA,CAAA,EAAA,QAAD","file":"sw.b6335150.js","sourceRoot":"..","sourcesContent":["// Incrementing OFFLINE_VERSION will kick off the install event and force\n// previously cached resources to be updated from the network.\nconst OFFLINE_VERSION = 1;\nconst CACHE_NAME = \"offline\";\nconst OFFLINE_URL = \"index.html\";\n\nself.addEventListener(\"install\", (event) => {\n  event.waitUntil(\n    (async () => {\n      const cache = await caches.open(CACHE_NAME);\n      // Setting {cache: 'reload'} in the new request will ensure that the response\n      // isn't fulfilled from the HTTP cache; i.e., it will be from the network.\n      await cache.add(new Request(OFFLINE_URL, { cache: \"reload\" }));\n    })()\n  );\n});\n\nself.addEventListener(\"activate\", (event) => {\n  event.waitUntil(\n    (async () => {\n      // Enable navigation preload if it's supported.\n      // See https://developers.google.com/web/updates/2017/02/navigation-preload\n      if (\"navigationPreload\" in self.registration) {\n        await self.registration.navigationPreload.enable();\n      }\n    })()\n  );\n\n  // Tell the active service worker to take control of the page immediately.\n  self.clients.claim();\n});\n\nself.addEventListener(\"fetch\", (event) => {\n  // We only want to call event.respondWith() if this is a navigation request\n  // for an HTML page.\n  if (event.request.mode === \"navigate\") {\n    event.respondWith(\n      (async () => {\n        try {\n          // First, try to use the navigation preload response if it's supported.\n          const preloadResponse = await event.preloadResponse;\n          if (preloadResponse) {\n            return preloadResponse;\n          }\n\n          const networkResponse = await fetch(event.request);\n          return networkResponse;\n        } catch (error) {\n          // catch is only triggered if an exception is thrown, which is likely\n          // due to a network error.\n          // If fetch() returns a valid HTTP response with a response code in\n          // the 4xx or 5xx range, the catch() will NOT be called.\n          console.log(\"Fetch failed; returning offline page instead.\", error);\n\n          const cache = await caches.open(CACHE_NAME);\n          const cachedResponse = await cache.match(OFFLINE_URL);\n          return cachedResponse;\n        }\n      })()\n    );\n  }\n\n  // If our if() condition is false, then this fetch handler won't intercept the\n  // request. If there are any other fetch handlers registered, they will get a\n  // chance to call event.respondWith(). If no fetch handlers call\n  // event.respondWith(), the request will be handled by the browser as if there\n  // were no service worker involvement.\n});\n"]}